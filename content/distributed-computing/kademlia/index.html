---
title: "Kademlia"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#resources">Resources</a></li>
		</ul>
	</li>
</ul>

<h3 id="introduction">Introduction</h3>


<h3 id="introduction">Identifiers</h3>

<p>
  Each Kademlia node has a random \(160\)-bit node ID.
</p>



<h3 id="introduction">Tree Representation</h3>

<p>
  Kademlia effectively treats nodes as leaves in a binary tree with each node's position being determined by the shortest unique prefix of its ID. For any given node, we divide the binary tree into a series of successively lower subtrees that don't contain the node. The highest subtree consists of the half of the binary tree not containing the node. The next subtree consists of the half of the remaining tree not containing the node and so on.
</p>

<figure>
  <img src="/img/kademlia/binary-tree.svg" style="max-height: 180px;" alt="">
  <figcaption>
    Figure X
  </figcaption>
</figure>

<p>
  For example, in <i>figure 1</i>, we consider the position of a node with unique prefix 0011. The subtrees are circled and consist of all nodes with prefixes 1, 01, 000 and 0010 respectively.
</p>


<h3 id="introduction">XOR Metric</h3>

<p>
  Kademlia defines the distance between two \(160\)-bit identifiers \(x\) and \(y\) as their bitwise exclusive or (XOR) interpreted as an integer \(d(x,y) = x \oplus y\). This is a valid, albeit non-Euclidean metric which satisfies the following properties:
</p>



<p>
  XOR captures the notion of distance implicit in the binary tree representation. In a fully-populated binary tree of 160-bit IDs, the magnitude of the distance between two IDs is the height of the smallest subtree containing them both. When a tree is not fully populated, the closest leaf to an ID \(x\) is the leaf whose id shares the longest common prefix of \(x\). If there are empty branches in the tree, there might be more 
</p>


<p>
  XOR is unidirectional. For any given point \(x\) and distance \(\Delta > 0\), there is exactly one point \(y\) such that \(d(x,y) = \Delta\). Unidirectionality ensures that all lookups for the same key converge along the same path, regardless of the originating node.
</p>



<h3 id="introduction">Node State</h3>

<p>
  Nodes store contact information about each other to route query messages. For each \(0 \le i &lt; 160\), every node keeps a list of〈IP Address, UDP Port, Node ID〉triples for nodes of distance between \(2^i\) and \(2^{i+1}\) from itself. We call these lists \(k\)-buckets. Each \(k\)-bucket is kept sorted by time last seen with the least-recently seen node at the head and the most-recently seen at the tail. For small values of \(i\), the \(k\)-buckets will generally be empty. For large values of \(i\), the lists can grow up to size \(k\) where \(k\) is a system-wide replication parameter.
</p>

<figure>
  <img src="/img/kademlia/k-buckets.svg" style="max-height: 250px;" alt="">
  <figcaption>
    Figure X
  </figcaption>
</figure>

<p>
  When a node receives a request or reply from another node, it updates the appropriate \(k\)-bucket for the sender's node ID as follows:
</p>

<ul>
  <li>
    If the sending node already exists in the recipient's \(k\)-bucket then the recipient moves it to the tail of the list.
  </li>
  <li>
    If the node is not already in the appropriate \(k\)-bucket, then:
    <ul>
      <li>
        If the bucket has fewer than \(k\) entries then the recipient just inserts the new sender at the tail of the list.
      </li>
      <li>
        If the appropriate \(k\)-bucket is full, then the recipient pings the \(k\)-bucket's least recently seen node to decide what to do.
        <ul>
          <li>
            If the node responds then it is moved to the tail of the list and the new sender's contact is discarded.
          </li>
          <li>
            If the node fails to respond then it is evicted from the \(k\)-bucket and the new sender is inserted at the tail.
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>
  This approach effectively implements a least-recently seen eviction policy except that live nodes are never removed from the list. Indeed, by keeping the oldest live contacts around Kademlia looks to maximize the probability that the nodes \(k\)-buckets contain will remain online. Furthermore, this provides resistance to certain DoS attacks as one cannot flush nodes' routing state by flooding the system with new nodes. Nodes will only insert the new nodes in the \(k\)-buckets when old nodes leave the system.
</p>


<h3 id="introduction">Protocol</h3>

The Kademlia protocol consists of four RPCs: <code>PING</code>, <code>STORE</code>, <code>FIND_NODE</code> and <code>FIND_VALUE</code>. <code>PING</code> probes a node to see if it is online. <code>STORE</code> instructs a node to store a〈key, value〉pair for later retrieval.


<h4 id="ping">Ping</h4>

<p>
  <code>FIND_NODE</code> takes a \(160\)-bit ID as an argument. The recipient the RPC returns 
</p>

<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="http://www.scs.stanford.edu/~dm/home/papers/kpos.pdf">Kademlia: A Peer-to-peer Information System Based on the XOR Metric</a>
  </li>
  <li>
    <a href="https://en.wikipedia.org/wiki/Metric_(mathematics)#Definition">Metric Definition (Wikipedia)</a>
  </li>
  <li>
    <a href="https://developpaper.com/kademlia-protocol/">Kademlia Protocol Overview</a>
  </li>
  <li>
    <a href="https://stackoverflow.com/questions/25751928/kademlia-xor-metric-properties-purposes">Purposes of XOR Metric Properties</a>
  </li>
</ul>

<!-- 
  https://metaquestions.me/2014/08/01/shortest-distance-between-two-points-is-not-always-a-straight-line/

  https://developpaper.com/kademlia-protocol/

  http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html#intro

  https://www.youtube.com/watch?v=w9UObz8o8lY

  https://github.com/nictuku/dht
-->
