---
title: "BitTorrent"
date: 2020-09-29
draft: false
---

<ul>
  <li>
    <a href="#introduction">Introduction</a>
  </li>
  <li>
    <a href="#resources">Resources</a>
  </li>
</ul>


<h3 id="introduction">Introduction</h3>

<p>

</p>

<!-- 
  BitTorrent is a peer-to-peer file-sharing protocol designed to facilitate file transfers among multiple peers across unreliable networks.

  It uses tit-for-tat as a method of seeking pareto efficiency.

  It achieves a high level of robustness and resource utilization.

  When a file is made available using HTTP, all upload cost is placed on the hosting machine.

  With BitTorrent, when multiple people are downloading the same file at the same time, they upload pieces of the file to each other.

  This redistributes the cost of upload to downloaders thus making hosting a file with a potentially unlimited number of downloaders affordable.

  BitTorrent is a protocol for downloading and distributing files across the internet.

  Participants in the BitTorrent network, called peers, download pieces of files from each other.
-->




<h3 id="data-representation"></h3>

<!--
  A torrent may consist of one or more files which are treated as a contiguous sequence of bytes.

  The byte sequence is broken into equally sized pieces which are further divided into blocks.

  Peers exchange blocks which are reassembled into files.

  A peer can only share the complete pieces it has but breaking a piece up into blocks enables allows it to be downloaded from multiple pairs.

  Once a peer has downloaded a piece, it can immediately begin sharing it with other peers.

  Because files are not padded to align with piece boundaries, the last piece may be smaller than the rest.

  vvv 
  https://mandreyel.github.io/posts/rust-bittorrent-engine/
-->


<h3 id="hashing">Hashing</h3>

<!-- 
  In order to keep track of which peers have what, BitTorrent cuts files into pieces of fixed size, typically a quarter megabyte.

  Each downloader reports to all of its peers what pieces it has.

  To verify data integrity, the SHA1 hashes of all the pieces are included in the .torrent file and peers don't report that they have a piece until they've checked the hash.

  Peers continuously download pieces from all peers which they can.

  They of course cannot download from peers they aren’t connected to, and sometimes peers don’t have any pieces they want or won’t currently let them download.
-->


<h3 id="metainfo-file">Metainfo File</h3>

<!-- 
  The decision to use BitTorrent is made by the publisher of a file.

  The metainfo file contains information about the file: its length, name, hashing information and the url of a tracker.

  When someone wants to publish data using the BitTorrent protocol, they must create a metainfo file.

  All data in a metainfo file is bencoded.

  The content of a metainfo file is a bencoded dictionary containing an info key that describes the 
-->



<h3 id="pipelining">Pipelining</h3>

<!-- 
  When transferring data over TCP, it is very important to always have several requests pending at once to avoid a delay between pieces being sent.

  BitTorrent facilitates this by breaking pieces further into sub-pieces over the wire, typically 16 KB in size, and always keeping some number, typically five, requests pipelined at once.

  Every time a sub-piece arrives a new request is sent.

  The amount of data to pipeline has been selected as a value which can reliably saturate most connections.
-->



<h3 id="piece-selection">Piece Selection</h3>

<!-- 
  Selecting pieces to download in a good order is very important for good performance.

  Strict Policy:

    Once a single sub-piece has been requested, the remaining sub-pieces from that particular piece are requested before sub-pieces from any other piece.

    This does a good job of getting complete pieces as quickly as possible.


  Rarest First:

    When selecting which piece to start downloading next, peers generally download pieces which the fewest of their own peers have first.

    This technique does a good job of making sure that peers have pieces which all of their peers want so uploading can be down when wanted.

    It also makes sure that pieces which are more common are left for later so the likelihood that a peer which is currently offering upload will later not have anything of interest is reduced.

    Additionally, since no downloaders can complete until the seed has uploaded every part of the file, performance is much better if different downloaders get different pieces from the seed since redundant downloads waste the opportunity for the seed to get more information out.

    Rarest first does a good job of only downloading new pieces from the seed, since downloaders will be able to see that their other peers have pieces the seed has uploaded already.

    Replicating the rarest pieces as quickly as possible reduces the risk of them getting completely lost as current peers stop uploading.


  Random First Piece:

    An exception to rarest first is when downloading starts.

    At that time, the peer has nothing to upload so it's important to get a complete piece as quickly as possible.

    Rare pieces are generally only present on one peer so they would be downloaded slower than pieces which are present on multiple peers for which it's possible to download sub-pieces from different places.

    For this reason, pieces to download are selected at random until the first complete piece is assembled and then the strategy changes to rarest first.
-->



<h3 id="endgame-mode">Endgame Mode</h3>

<!-- 
  Sometimes a piece will be requested from a peer with very slow transfer rates.

  This isn't a problem in the middle of a download but it could potentially delay a download's finish.

  To prevent this, once all sub-pieces which a peer doesn't have are actively requested it sends requests for all sub-pieces to all peers.

  Cancels are sent for sub-pieces which arrive to keep too much bandwidth from being wasted on redundant sends.

  In practice not much bandwidth is wasted as the endgame period is very short.

  While normally each block is requested from a single peer, blocks in the last pending pieces should be downloaded from all peers, on a “whoever sends it first” basis. Once they arrive, requests to the slower peers are simply cancelled. This wastes some bandwidth but saves quite a bit of time.
-->



<h3 id="choking">Choking</h3>

<!--
  BitTorrent does no central resource allocation.

  Each peer is responsible for attempting to maximize its own download rate.

  Peers do this by downloading from whoever they can and deciding which peers to upload to via a variant of tit-for-tat.

  To cooperate, peers upload and to not cooperate they choke peers.

  Choking is a temporary refusal to upload; it stops uploading but downloading can still happen and the connection doesn’t need to be renegotiated when choking stops.

  A good choking algorithm should utilize all available resources, provide reasonably consistent download rates for everyone, and be somewhat resistant to peers only downloading and not uploading.

  Each BitTorrent peer always unchokes a fixed number of other peers (default is four).

  This approach allows TCP's builtin congestion control to reliably saturate upload capacity.

  Decisions as to which peers to unchoke are based strictly on current download rate.
  
  Calculating current download rate meaningfully is a surprisingly difficult problem; The current implementation essentially uses a rolling 20-second average.

  To avoid situations in which resources are wasted by rapidly choking and unchoking peers, BitTorrent peers recalculate who they want to choke once every ten seconds, and then leave the situation as is until the next ten second period is up.
  
  Ten seconds is a long enough period of time for TCP to ramp up new transfers to their full capacity.
-->


<h3 id="optimistic-unchoking">Optimistic Un-choking</h3>

<!-- 
  Simply uploading to the peers which provide the best download rate would suffer from having no method of discovering if currently unused connections are better than the ones being used.

  To fix this, at all times, a BitTorrent peer has a single 'optimistic unchoke' which is unchoked regardless of the current download rate from it.

  Which peer is the optimistic unchoke is rotated every third rechoke period (30 seconds).

  30 seconds is enough time for the upload to get to full capacity, the download to reciprocate, and the download to get to full capacity.
-->


<h3 id="anti-snubbing">Anti-snubbing</h3>


<!-- 
  Occasionally a BitTorrent peer will be choked by all
peers which it was formerly downloading from. In
such cases it will usually continue to get poor download
rates until the optimistic unchoke finds better
peers. To mitigate this problem, when over a minute
goes by without getting a single piece from a particular
peer, BitTorrent assumes it is ’snubbed’ by
that peer and doesn’t upload to it except as an optimistic
unchoke. This frequently results in more than
one concurrent optimistic unchoke, (an exception to
the exactly one optimistic unchoke rule mentioned
above), which causes download rates to recover much
more quickly when they falter.
-->



<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://www.bittorrent.org/bittorrentecon.pdf">Incentives Build Robustness in BitTorrent (Bram Cohen)</a>
  </li>
  <li>
    <a href="https://www.bittorrent.org/beps/bep_0003.html">Official Specification</a>
  </li>
</ul>

