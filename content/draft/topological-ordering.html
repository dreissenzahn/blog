---
title: "Topological Ordering (DRAFT)"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#khans-algorithm">Khan's Algorithm</a>
      </li>
      <li>
        <a href="#depth-first-search">Depth-First Search</a>
      </li>
      <li>
        <a href="#complexity">Complexity</a>
      </li>
      <li>
        <a href="#implementation">Implementation</a>
      </li>
      <li>
        <a href="#resources">Resources</a>
      </li>
		</ul>
	</li>
</ul>



<h3 id="introduction">Introduction</h3>

<p>
  A topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge \((u, v)\) from vertex \(u\) to vertex \(v\), \(u\) comes before \(v\) in the ordering. A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a directed acyclic graph (DAG). Any DAG has at least one topological ordering.
</p>

<!-- 
  Let G = (V, E) be a directed graph. A topological ordering of G is an assignment f(v) of every vertex v \in V to a different number such that for every (v, w) \in E, f(v) < f(w).

  The function f effectively orders the vertices, from the vertex with the smallest f-value to the one with the largest. The condition asserts that all of G's (directed) edges should travel forward in the ordering, with the label of the tail of an edge smaller than that of its head.

  You can visualize a topological ordering by plotting the vertices in order of their f-values. In a topological ordering, all edges of the graph are directed from left to right.

  Problem: Given a directed acyclic graph G = (V, E), compute a topological ordering of the vertices of G.
-->

<!-- 
  Does every graph have a topological ordering? No way. Think about
a graph consisting solely of a directed cycle (Figure 8.11(a)). No
matter what vertex ordering you choose, traversing the edges of the
cycle takes you back to the starting point, which is possible only if
some edges go backward in the ordering (Figure 8.11(b)).
More generally, it is impossible to topologically order the vertices
of a graph that contains a directed cycle. Equivalently, it is impossible
to sequence a set of tasks when their dependencies are circular.
Happily, directed cycles are the only obstruction to topological
orderings. A directed graph without any directed cycles is called—wait for it—a directed acyclic graph, or simply a DAG. For example,
the graph in Figure 8.10 is directed acyclic; the graph in Figure 8.11
is not.

Theorem: Every directed acyclic graph has at least one topological ordering.

A source vertex of a directed graph is a vertex with no
incoming edges. (Analogously, a sink vertex is one with no outgoing
edges.)
-->

<figure>
  <img src="/img/topological-ordering/.svg" style="max-width: 300px;">
  <figcaption>
    <i>figure 3</i>
  </figcaption>
</figure>

<p>

</p>

<!-- 
  For example, the vertices of the graph may represent tasks to be performed and the edges may represent constraints that one task must be performed before another; in this case, a topological ordering is just a valid sequence for the tasks.

  The canonical application of topological sorting is in scheduling a sequence of jobs or tasks based on their dependencies. The jobs are represented by vertices, and there is an edge from x to y if job x must be completed before job y can be started. Then, a topological sort gives an order in which to perform the jobs.
-->

<!-- 
  Imagine that you have a bunch of tasks to complete and there are precedence constraints, meaning that you cannot start some of the tasks until you have completed others. One application of topological orderings is to sequencing tasks so that all precedence constraints are respected.

  When the vertices of a graph represent tasks and the directed edges represent precedence constraints, topological orderings correspond exactly to the different ways to sequence the tasks while respecting the precedence constraints.
-->


<h3 id="khans-algorithm">Khan's Algorithm</h3>

<p>
  Kahn's algorithm finds a topological ordering by repeatedly removing vertices in the graph which have no incoming edges. When a vertex is removed it is added to the topological ordering and all its edges are removed which decreases the incoming degrees of other vertices. This process is repeated until all vertices are processed or until a cycle is discovered.
</p>

<ol>
  <li>
    Count the incoming degree of each vertex.
  </li>
  <li>
    Add all vertices with an incoming degree of zero to a queue.
  </li>
  <li>
    Remove the vertex at the front of the queue and add it to the topological ordering.
  </li>
  <li>
    Decrement the incoming degree of all the vertices adjacent to the removed vertex.
  </li>
  <li>
    If the incoming degree of any of the adjacent vertices is decremented to zero then add it to the back of the queue.
  </li>
  <li>
    Repeat steps 3-5 until the queue is empty.
  </li>
</ol>

<figure>
  <img src="/img/raft/previous-terms.svg" style="max-width: 230px;" alt="">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>



<h3 id="depth-first-search">Depth-First Search</h3>

<!-- 

-->

<!-- An alternative algorithm for topological sorting is based on depth-first search. The algorithm loops through each node of the graph, in an arbitrary order, initiating a depth-first search that terminates when it hits any node that has already been visited since the beginning of the topological sort or the node has no outgoing edges (i.e. a leaf node):

L ← Empty list that will contain the sorted nodes
while exists nodes without a permanent mark do
    select an unmarked node n
    visit(n)

function visit(node n)
    if n has a permanent mark then
        return
    if n has a temporary mark then
        stop   (not a DAG)

    mark n with a temporary mark

    for each node m with an edge from n to m do
        visit(m)

    remove temporary mark from n
    mark n with a permanent mark
    add n to head of L

Each node n gets prepended to the output list L only after considering all other nodes which depend on n (all descendants of n in the graph). Specifically, when the algorithm adds node n, we are guaranteed that all nodes which depend on n are already in the output list L: they were added to L either by the recursive call to visit() which ended before the call to visit n, or by a call to visit() which started even before the call to visit n. Since each edge and node is visited once, the algorithm runs in linear time. This depth-first-search-based algorithm is the one described by Cormen et al. (2001); it seems to have been first described in print by Tarjan (1976). -->



<h3 id="complexity">Complexity</h3>

<p>
</p>

<!-- The usual algorithms for topological sorting have running time linear in the number of nodes plus the number of edges, asymptotically, O(|V| + |E|). -->



<h3 class="implementation">Implementation</h3>

<pre><code class="java"></code></pre>



<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorting (Wikipedia)</a>
  </li>
  <li>
    <a href="https://www.youtube.com/watch?v=ozso3xxkVGU&list=PLXFMmlk03Dt7Q0xr1PIAriY5623cKiH7V&index=50">Topological Sort (YouTube)</a>
  </li>
  <li>
    <a href="https://www.youtube.com/watch?v=cIBFEhD77b4">Kahn's Algorithm (YouTube)</a>
  </li>
</ul>
