---
title: "Breadth-First Search (DRAFT)"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#procedure">Procedure</a>
      </li>
      <li>
        <a href="#implementation">Implementation</a>
      </li>
      <li>
        <a href="#complexity">Complexity</a>
      </li>
      <li>
        <a href="#resources">Resources</a>
      </li>
		</ul>
	</li>
</ul>


<h3 id="introduction">Introduction</h3>

<p>
  Breadth-first search is a graph traversal algorithm. Given a graph \(G = (V, E)\) and a source vertex \(s\), it explores the graph to discover every vertex reachable from \(s\). The algorithm cautiously explores the graph in layers starting from the first layer which consists of the starting vertex \(s\). Subsequent layers consist of those vertices that are the neighbors of the previous layer's vertices that do not appear in any earlier layer.
</p>

<figure>
  <img src="/img/graph-traversal/bfs-layers.svg" style="max-width: 350px;" alt="">
  <figcaption>
    <i>figure 1</i>
  </figcaption>
</figure>



<h3 id="procedure">Traversal</h3>

<p>
  To traverse a graph, breadth-first search proceeds as follows:
</p>

<ol>
  <li>
    Initialize an empty queue.
  </li>
  <li>
    Mark the source vertex as visited and enqueue it.
  </li>
  <li>
    Dequeue a vertex and consider each of its adjacent vertices.
  </li>
  <li>
    If a vertex adjacent to the dequeued vertex has not been visited then mark it as visited and enqueue it.
  </li>
  <li>
    Repeat steps 3-4 until the queue is empty.
  </li>
</ol>

<figure>
  <img src="/img/graph-traversal/graph-traversal.svg" style="max-width: 300px;" alt="">
  <figcaption>
    <i>figure 2</i>
  </figcaption>
</figure>


<h3 class="">Shortest Paths</h3>

<!-- 
  Breath-first search can be augmented to compute shortest-path distances.

  In a graph G, we use the notation dist(v,w) for the fewest number of edges in a path from v to w (or +1, if G contains no path from v to w).
 -->


<h3 class="complexity">Complexity</h3>

<p>
  Both breath-first search and depth-first search have worst-case performance of \(O(|V| + |E|)\) and worst-case space complexity of \(O(|V|)\).
</p>

<!-- 
Graph traversal may require that some vertices be visited more than once, since it is not necessarily known before transitioning to a vertex that it has already been explored.

Thus, it is usually necessary to remember which vertices have already been explored by the algorithm, so that vertices are revisited as infrequently as possible (or in the worst case, to prevent the traversal from continuing indefinitely).
-->



<h3 class="implementation">Implementation</h3>

<pre><code class="java">public class BreadthFirstSearch {

  public static void traverse(List<List<Integer>> g, int start) {
    boolean[] visited = new boolean[g.size()];
    Queue<Integer> queue = new LinkedList<>();

    visited[start] = true;
    queue.offer(start);

    int count = 0;

    System.out.print("traversal order: ");

    while (!queue.isEmpty()) {
      int v = queue.poll();
      count++;
      System.out.print(v + " ");
      for (Integer w : g.get(v)) {
        if (!visited[w]) {
          visited[w] = true;
          queue.offer(w);
        }
      }
    }

    System.out.println("\ntotal vertices: " + count);
  }

  public static void shortestPath(List<List<Integer>> g, int start, int end) {
    int n = g.size();

    boolean[] visited = new boolean[n];
    Integer[] prev = new Integer[n];
    
    Queue<Integer> queue = new LinkedList<>();

    visited[start] = true;
    queue.offer(start);

    while (!queue.isEmpty()) {
      int v = queue.poll();
      for (Integer w : g.get(v)) {
        if (!visited[w]) {
          visited[w] = true;
          prev[w] = v;
          queue.offer(w);
        }
      }
    }

    List<Integer> path = new ArrayList<>();
    for (Integer v = end; v != null; v = prev[v])
      path.add(v);
    Collections.reverse(path);

    if (path.get(0) != start)
      System.out.println("path does not exist!");

    System.out.println("shortest path: " + path);
  }
}</code></pre>



<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://en.wikipedia.org/wiki/Graph_traversal">Graph Traversal (Wikipedia)</a>
  </li>
  <li>
    <a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth First Search (Wikipedia)</a>
  </li>
  <li>
    <a href="https://www.youtube.com/watch?v=73qCvXsYkfk">Breadth First Search (Stanford Algorithms)</a>
  </li>
</ul>

<!-- 
  10 4 BFS and Undirected Connectivity 13 min
  https://www.youtube.com/watch?v=vHqaiQlOzOw

  Algorithms Illuminated (Part II) Chapter 8
-->
