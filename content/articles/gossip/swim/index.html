---
title: "SWIM"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#failure-detection">Failure Detection</a></li>
				<li><a href="#resources">Resources</a></li>
		</ul>
	</li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>
  Scalable Weakly-consistent Infection-style Process Group Membership Protocol (SWIM) provides weakly-consistent knowledge of group membership to all participants of a process group. This is achieved in a scalable way by avoiding heart-beating in favor of using a random peer-to-peer probing of processes. Membership updates are propagated efficiently and reliably in infection-style by piggybacking on packets generated by the failure detector protocol.
</p>


<p>
  Benefits of SWIM include:
</p>

<ol>
  <li>
    imposes a constant message load per group member;
  </li>
  <li>
    detects a process failure in an (expected) constant time at some non-faulty process in the group;
  </li>
  <li>
    provides a deterministic bound (as a function of group size) on the local time that a non-faulty process takes to detect failure of another process;
  </li>
  <li>
    propagates membership updates, including information about failures, in infection-style; the dissemination latency in the group grows slowly (logarithmically) with the number of members;
  </li>
  <li>
    provides a mechanism to reduce the rate of false positives
    by “suspecting” a process before “declaring” it as
    failed within the group.
  </li>
</ol>

<p>
  The SWIM divides its approach into two components: a Failure Detector Component that detects failures of members and a Dissemination Component that disseminates information about members that have recently joined, left or failed.
</p>


<h3 id="membership-protocols">Membership Protocols</h3>

<p>
  A membership protocol provides each member of a group of processes with a locally-maintained list of other non-faulty processes in the group. The protocol ensures that this membership list is updated with changes resulting from new members joining the group or dropping out (either voluntarily or as a result of failure).
</p>


<h3 id="failure-detection">Failure Detection</h3>

<p>
  Consider an arbitrary member \(M_i\). During each protocol period of length \(T'\) time units on <nobr>\(M_i\)’s</nobr> local clock, the failure detection protocol proceeds as follows:
</p>

<ul>
  <li>
    \(M_i\) selects a random member \(M_j\) from its membership list, sends it a <i>ping</i> and waits for a replying <i>ack</i> from \(M_j\).
  </li>
  <li>
    If this <i>ack</i> is not received within a pre-specified timeout then \(M_i\) indirectly probes \(M_j\):
    <ul>
      <li>
        \(M_i\) randomly selects \(k\) members from its membership list and sends each of these members a <i>ping-req(\(M_j\))</i>.
      </li>
      <li>
        On receiving this message, each of these \(k\) members sends a <i>ping</i> to \(M_j\).
      </li>
      <li>
        If any of the \(k\) members receives an <i>ack</i> back from \(M_j\) they forward it back to \(M_i\).
      </li>
    </ul>
  </li>
  <li>
    At the end of the protocol period, \(M_i\) checks if it has received an <i>ack</i> either directly from \(M_j\) or indirectly through one of the \(k\) members.
  </li>
  <li>
    If no such <i>ack</i> has been received, \(M_i\) declares \(M_j\) as failed in its local membership list and hands this update to the Dissemination Component.
  </li>
</ul>

<figure>
  <img src="/img/swim/failure-detection.svg" height="400" alt="">
  <figcaption>
    Figure 1
  </figcaption>
</figure>


<h3 id="infection-style-dissemination-component">Infection-Style Dissemination Component</h3>

<p>
  The basic SWIM protocol propagates membership updates using an external multicast primitive. However, hardware multicast and IP multicast are unreliable and rarely enabled. As such, the augmented SWIM protocol eliminates the use of an multicast primitive by piggybacking information to be disseminated on the <i>ping</i>, <i>ping-req</i> and <i>ack</i> messages generated by the failure detector protocol. The result is an infection-style dissemination mechanism that is resilient to process failures and message loss.
</p>

<p>
  The SWIM protocol layer at each group member \(M_i\) maintains a buffer of recent membership updates, along with a local count for
  each buffer element. The local count specifies the number of times the element has been piggybacked so far by \(M_i\). Each element is piggybacked at most \(\lambda \log n\) times where \(n\) is the number of members and \(\lambda\) is a parameter. If the size of this buffer is larger than the maximum number of elements that can be piggybacked on a single <i>ping</i> or <i>ack</i>, elements that have been gossiped fewer times are preferred.
</p>

<p>
  It is necessary to prefer membership updates that have been gossiped fewer times because the protocol period is fixed and the rate of membership changes might temporarily overwhelm the speed of dissemination. Preferring buffer elements with lower counts under such circumstances ensures that all membership changes infect at least a few members. When the membership change rate quiesces, these changes will propagate through the rest of the group.
</p>

<p>
  The original paper’s implementation actually maintained two lists of group members: a list of members that are not yet declared as failed in the group, and a second list of members that have failed recently. Currently, an equal number of buffer of elements is chosen from these two lists for piggybacking but the scheme can be generalized to adapt to relative variations in process join, leave and failure rates.
</p>


<h3 id="resources">Round-Robin Probe Target Selection</h3>

<p>

</p>

The basic SWIM failure detector protocol detects failures in an average constant number of protocol periods. Although each process failure is guaranteed to be detected eventually at every other non-faulty process, a pathological selection
of ping targets across the group might lead to a large
delay in the first detection of the process failure anywhere
in the group. In the extreme case, this delay could be unbounded
as the failed process might never be chosen as a
ping target by any other non-faulty process.

This can be solved by the following modification to the
protocol. The failure detection protocol at member $M_i$
works by maintaining a list (intuitively, an array) of 
the
known elements of the current membership list, and selecting
ping targets not randomly from this list, but in a roundrobin
fashion. Instead, a newly joining member is inserted
in the membership list at a position that is chosen uniformly
at random. On completing a traversal of the entire list, $M_i$
rearranges the membership list to a random reordering.

Consider the execution of the SWIM protocol, modified
as described above, at member $M_i$. Once another member $M_j$ is included in $M_i$'s membership list, it will be chosen
as a ping target exactly once during each traversal of $M_i$'s membership list. If the size of the membership list is no
more than $n_i$, successive selections of the same target are at
most $(2n_i -1)$ protocol periods apart. This bounds the worst case detection time of a process failure of any member
by $M_i$, thus satisfying a Time Bounded Completeness
property.

The average failure detection time of the original protocol
is preserved by this optimization, since the randomization
of the membership lists at different members across the
group leads to a similar distribution of ping target choices
by each member.









<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://research.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf">Scalable Weakly-consistent Infection-style Process Group Membership Protocol</a>
  </li>
  <li>
    <a href="https://arxiv.org/pdf/1707.00788.pdf">Lifeguard: Local Health Awareness for More Accurate Failure Detection</a>
  </li>
</ul>


