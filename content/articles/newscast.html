---
title: "Newscast"
date: 2020-09-30
draft: false
---

<ul class="contents">
	<li>
		<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#failure-detection">Failure Detection</a></li>
				<li><a href="#resources">Resources</a></li>
		</ul>
	</li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>
  Newscast is a general approach for communication in large agent-based distributed systems. It provides both membership management and information dissemination services using the same gossip protocol. Agents can join and leave the network at virtually no cost at all, and without affecting the information-dissemination properties of the protocol.
</p>

In this paper, we concentrate on information-dissemination based systems that deploy epidemic protocols.

Traditional protocols supported this random selection by providing a list of all other participating peers. Clearly, such an approach cannot scale to large networks. 

In newscast, a large group of agents is connected through a simple peer-to-peer data exchange protocol. The protocol is extremely simple: each agent knows only a (continuously changing) small set of peers of which one is randomly chosen to exchange information.


<h3 id="resources">Agencies</h3>

<p>
  The two main building blocks of the newscast model are a collective of <i>agents</i> and a <i>news agency</i>. The basic idea is that the news agency asks all agents regularly for news by means of a callback function <code>getNews()</code>. In addition, the news agency provides each agent with news about the other agents in the collective through a callback function <code>newsUpdate(news[])</code>.
</p>

<figure>
  <img src="/img/newscast/news-agency.svg" height="300" alt="">
  <figcaption>
    Figure 1
  </figcaption>
</figure>


<p>
  Agents perform computations and based on those computations and the information they have collected they must provide the news agency with news when asked. The definition of <i>news</i> is application dependent. 
</p>

<figure>
  <img src="/img/newscast/cache-entry.svg" height="130" alt="">
  <figcaption>
    Figure 1
  </figcaption>
</figure>

<h3 id="resources">Correspondents</h3>

<p>
  Each agent has an associated <i>correspondent</i> that runs on the same machine hosting the agent. The correspondents jointly form the distributed implementation of the news agency. Each correspondent maintains a fixed-sized cache of \(c\) news items. Whenever an agent passes a news item to its correspondent, the later timestamps the item, adds its own network address and subsequently caches the item. A news item itself consists of an agent identifier and the actual news as provided by the agent.
</p>

<p>
  Correspondents regularly exchange caches. Each correspondent executes the following five steps once every \(\Delta t\) time units (\(\Delta t\) is referred to as the <i>refresh interval</i>):
</p>

<ol>
  <li>
    Request a fresh news item from the local agent by calling <code>getNews()</code>. Add the item to the cache.
  </li>
  <li>
    Randomly select a peer correspondent by considering the network address of other (and available) correspondent as found in the cache.
  </li>
  <li>
    Send all cache entries to the selected peer and, in turn, receive all the peer's cache entries. Merge the received entries into the local cache.
  </li>
  <li>
    Pass the received cache entries from the peer agent to the local agent by calling <code>newsUpdate()</code>.
  </li>
  <li>
    The correspondent now has \(2c\) cache entries; it subsequently throws away the \(c\) oldest ones.
  </li>
</ol>

<p>
  The selected peer correspondent executes the last three steps as well, so that after the exchange both correspondents have the same cache. Note, however, that as soon as any of these two correspondents executes the protocol again, their respective caches will most likely be different again.
</p>

<p>
  The protocol does not require that the clocks of correspondents are synchronized, but only that the timestamps of news items in a single cache are mutually consistent. We assume that the communication time between two correspondents is negligible in comparison to \(\Delta T\) (which is generally in the order of minutes).
</p>

<p>
  When a correspondent \(A\) passes its cache to \(B\), it also sends along its current local time, \(T_A\). When \(B\) receives the cache entries, it subsequently adjusts the timestamp of each entry with a value \(T_A - T_B\), effectively normalizing the time of each new entry to those already cached.
</p>


<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://www.researchgate.net/publication/2479853_Large-Scale_Newscast_Computing_on_the_Internet">Large-Scale Newscast Computing on the Internet</a>
  </li>
  <li>
    <a href="http://www.cs.unibo.it/bison/publications/ap2pc03.pdf">A Robust and Scalable Peer-to-Peer Gossiping Protocol</a>
  </li>
  <li>
    <a href="https://link.springer.com/chapter/10.1007/978-3-319-31204-0_20">Reducing Efficiency of Connectivity-Splitting Attack on Newscast via Limited Gossip</a>
  </li>
  <li>
    <a href="https://github.com/nstehr/go-mansbridge">Golang Implementation</a>
  </li>
</ul>




