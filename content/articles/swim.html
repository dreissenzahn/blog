---
title: "SWIM"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
				<li><a href="#introduction">Introduction</a></li>
				<li><a href="#failure-detection">Failure Detection</a></li>
				<li><a href="#resources">Resources</a></li>
		</ul>
	</li>
</ul>

<h3 id="introduction">Introduction</h3>

<p>
  SWIM provides weakly-consistent knowledge of group membership to all participants of a process group. This is achieved in a scalable way by avoiding heart-beating in favor of using a random peer-to-peer probing of processes. Membership updates are propagated efficiently and reliably in infection-style by piggybacking on packets generated by the failure detector protocol.
</p>

<p>
  Benefits of SWIM include:
</p>

<ol>
  <li>
    imposes a constant message load per group member;
  </li>
  <li>
    detects a process failure in an (expected) constant time at some non-faulty process in the group;
  </li>
  <li>
    provides a deterministic bound (as a function of group size) on the local time that a non-faulty process takes to detect failure of another process;
  </li>
  <li>
    propagates membership updates, including information about failures, in infection-style; the dissemination latency in the group grows slowly (logarithmically) with the number of members;
  </li>
  <li>
    provides a mechanism to reduce the rate of false positives
    by “suspecting” a process before “declaring” it as
    failed within the group.
  </li>
</ol>

<p>
  The SWIM approach consists of two components: a Failure Detector Component, that detects failures of members, and a Dissemination Component, that disseminates information about members that have recently either joined or left the group, or failed.
</p>


<h3 id="failure-detection">Failure Detection</h3>

<p>
  Consider an arbitrary member \(M_i\). During each protocol period of length \(T'\) time units on <nobr>\(M_i\)’s</nobr> local clock, the Failure Detection protocol proceeds as follows:
</p>

<ul>
  <li>
    \(M_i\) selects a random member \(M_j\) from its membership list, sends it a <i>ping</i> and waits for a replying <i>ack</i> from \(M_j\).
  </li>
  <li>
    If this <i>ack</i> is not received within a pre-specified timeout then \(M_i\) indirectly probes \(M_j\):
    <ul>
      <li>
        \(M_i\) randomly selects \(k\) members from its membership list and sends each of these members a <i>ping-req(\(M_j\))</i>.
      </li>
      <li>
        On receiving this message, each of these \(k\) members sends a <i>ping</i> to \(M_j\).
      </li>
      <li>
        If any of the \(k\) members receives an <i>ack</i> from \(M_j\), they forward it back to \(M_i\).
      </li>
    </ul>
  </li>
  <li>
    At the end of the protocol period, \(M_i\) checks if it has received an <i>ack</i> either directly from \(M_j\) or indirectly through one of the \(k\) members.
  </li>
  <li>
    If no such <i>ack</i> has been received, \(M_i\) declares \(M_j\) as failed in its local membership list and hands this update to the Dissemination Component.
  </li>
</ul>

<figure>
  <img src="/img/figure.svg" height="400" alt="">
  <figcaption>
    Figure 1
  </figcaption>
</figure>


<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://research.cs.cornell.edu/projects/Quicksilver/public_pdfs/SWIM.pdf">Scalable Weakly-consistent Infection-style Process Group Membership Protocol</a>
  </li>
  <li>
    <a href="https://arxiv.org/pdf/1707.00788.pdf">Lifeguard: Local Health Awareness for More Accurate Failure Detection</a>
  </li>
</ul>


