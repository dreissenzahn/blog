---
title: "Docker"
date: 2020-09-29
draft: false
---

<ul class="contents">
	<li>
		<ul>
      <li>
        <a href="#introduction">Introduction</a>
      </li>
      <li>
        <a href="#resources">Resources</a>
      </li>
		</ul>
	</li>
</ul>



<h3 id="introduction">Introduction</h3>

<p>
  Docker is a platform for building, running and sharing application using containers. Containers leverage and share the host kernel, making them much more efficient in terms of system resources than virtual machines. Containers are secure as they isolate processes without any configuration required on the part of the user. Containers are portable so you can build locally, deploy to the cloud, and run anywhere.
</p>

<pre><code class="bash"># check docker version
$ docker --version

# test installation
$ docker run hello-world</code></pre>



<h3 id="">Architecture</h3>

<!-- 
  Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface.

  The Docker daemon (dockerd) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons to manage Docker services.

  The Docker client (docker) is the primary way that many Docker users interact with Docker. When you use commands such as docker run, the client sends these commands to dockerd, which carries them out. The docker command uses the Docker API. The Docker client can communicate with more than one daemon.

  A Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can even run your own private registry.

  When you use the docker pull or docker run commands, the required images are pulled from your configured registry. When you use the docker push command, your image is pushed to your configured registry.
 -->


<h3 id="">Objects</h3>

<!-- 
  IMAGES

  An image is a read-only template with instructions for creating a container. Often, an image is based on another image, with some additional customization.

  You might create your own images or you might only use those created by others and published in a registry. To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt.


  The docker build command builds Docker images from a Dockerfile and a “context”. A build’s context is the set of files located in the specified PATH or URL. The Docker build process can access any of the files located in the context.


  CONTAINERS

  A container is a runnable instance of an image. You can create, stop, move or delete a container using the Docker CLI. You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state.

  By default, a container is relatively well isolated from other containers and its host machine. You can control how isolated a container’s network, storage, or other underlying subsystems are from other containers or from the host machine.

  A container is defined by its image as well as any configuration options you provide to it when you create or start it. When a container is removed, any changes to its state that are not stored in persistent storage disappear.

  Fundamentally, a container is nothing but a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers. One of the most important aspects of container isolation is that each container interacts with its own private filesystem; this filesystem is provided by a Docker image. An image includes everything needed to run an application - the code or binary, runtimes, dependencies, and any other filesystem objects required.

  A container runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.


-->


<h3 id="">Docker CLI</h3>

<p>

</p>

<!-- docker hub -->

<pre><code class="bash"># show docker version
$ docker version

# show system information
$ docker info

# list available commands
$ docker help

# get help for a command
$ docker COMMAND --help

# show low-level information about object
$ docker inspect NAME|ID</code></pre>

<pre><code class="bash"># build an image from a dockerfile
$ docker build --tag TAG:VERSION PATH

# list images
$ docker images

# show history of an image
$ docker history IMAGE

# remove image
$ docker rmi IMAGE

# tag image
$ docker tag NAME|ID NAME[:TAG]</code></pre>

<pre><code class="bash">
# list running containers
$ docker ps
  
# list all containers
$ docker ps --all

# fetch the logs of a container
$ docker logs CONTAINER

# fetch the logs of a container and follow output
$ docker logs --follow CONTAINER

# show running processes of a container
$ docker top CONTAINER

# show resource usage statistics of container
$ docker stats CONTAINER

# list port mappings for container
$ docker port CONTAINER

# rename a container
$ docker rename CONTAINER NEW_NAME

# pause all processes within container
$ docker pause CONTAINER

# unpause all processes within container
$ docker unpause CONTAINER

# stop running container
$ docker stop CONTAINER

# start stopped container
$ docker start CONTAINER

# restart container
$ docker restart CONTAINER

# kill container
$ docker kill CONTAINER

# block until container stops
$ docker wait CONTAINER [CONTAINER ...]

# remove container
$ docker rm CONTAINER

# remove container
$ docker rm CONTAINER

# kill and remove container
$ docker rm --force CONTAINER

# remove container and any associated anonymous volumes
$ docker rm --volumes CONTAINER

# remove all stopped containers
$ docker rm $(docker ps -a -q)</code></pre>

<pre><code class="bash">
# run a command in a running container
$ docker exec CONTAINER COMMAND [ARG...]
</code></pre>

<pre><code class="bash">
# login in to docker registry
$ docker login

# logout of docker registry
$ docker logout

# search docker hub for images
$ docker search TERM

# pull an image from a registry
$ docker pull NAME[:TAG]

# push an image to a registry
$ docker push NAME[:TAG]
</code></pre>

<!-- 
  docker attach
  docker cp
  docker exec
  docker run

  docker volume
  docker volume create
  docker volume inspect
  docker volume ls
  docker volume prune
  docker volume rm
 -->


<h3 id="">Dockerfile</h3>

<p>
  Docker can build images automatically by reading the instructions from a Dockerfile. A Dockerfile contains all the commands a user could call on the command line to assemble an image. When we tell Docker to build our image by executing the docker build command, Docker reads these instructions and executes them one by one and creates a Docker image as a result.
</p>

<pre><code class="dockerfile"># set the base image for subsequent instructions
FROM <image>[:<tag>]

# add key-value pairs as metadata to an image
LABEL <key>=<value> ...

# execute a command in a new layer and commit the results
RUN <command>
RUN ["executable", "param1", "param2"]

# set directory for RUN, CMD, ENTRYPOINT, COPY and ADD instructions
WORKDIR /path/to/workdir

# copy files or directories from <src> to container at <dest>
COPY <src>... <dest>
COPY ["<src>",... "<dest>"]

# document that the container listens on the specified port
EXPOSE <port> [<port>/<protocol>...]

# set environment variables
ENV <key>=<value> ...

# define a variable that can be passed at built-time
ARG <name>[=<default value>]
</code></pre>


<h4>CMD</h4>

<pre><code class="dockerfile">
# 
CMD ["executable","param1","param2"]
CMD command param1 param2
</code></pre>

<!-- 
  There can only be one CMD instruction in a Dockerfile. If you list more than one CMD then only the last CMD will take effect.

  The main purpose of a CMD is to provide defaults for an executing container. These defaults can include an executable, or they can omit the executable, in which case you must specify an ENTRYPOINT instruction as well.

  If CMD is used to provide default arguments for the ENTRYPOINT instruction, both the CMD and ENTRYPOINT instructions should be specified with the JSON array format.

  Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, CMD [ "echo", "$HOME" ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: CMD [ "sh", "-c", "echo $HOME" ]. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.
-->




<h4>ENTRYPOINT</h4>

<!-- ENTRYPOINT has two forms:


ENTRYPOINT ["executable", "param1", "param2"]
ENTRYPOINT command param1 param2

An ENTRYPOINT allows you to configure a container that will run as an executable.

Command line arguments to docker run <image> will be appended after all elements in an exec form ENTRYPOINT, and will override all elements specified using CMD. This allows arguments to be passed to the entry point, i.e., docker run <image> -d will pass the -d argument to the entry point. You can override the ENTRYPOINT instruction using the docker run --entrypoint flag.

The shell form prevents any CMD or run command line arguments from being used, but has the disadvantage that your ENTRYPOINT will be started as a subcommand of /bin/sh -c, which does not pass signals. This means that the executable will not be the container’s PID 1 - and will not receive Unix signals - so your executable will not receive a SIGTERM from docker stop <container>.

Only the last ENTRYPOINT instruction in the Dockerfile will have an effect. -->


<h4>VOLUME</h4>

<pre><code class="dockerfile">
VOLUME ["/data"]
</code></pre>

<!-- 
  The VOLUME instruction creates a mount point with the specified name and marks it as holding externally mounted volumes from native host or other containers. The value can be a JSON array, VOLUME ["/var/log/"], or a plain string with multiple arguments, such as VOLUME /var/log or VOLUME /var/log /var/db. For more information/examples and mounting instructions via the Docker client, refer to Share Directories via Volumes documentation.

The docker run command initializes the newly created volume with any data that exists at the specified location within the base image. For example, consider the following Dockerfile snippet:

FROM ubuntu
RUN mkdir /myvol
RUN echo "hello world" > /myvol/greeting
VOLUME /myvol
This Dockerfile results in an image that causes docker run to create a new mount point at /myvol and copy the greeting file into the newly created volume.
 -->


<h3 id="dockerignore">.dockerignore</h3>

<p>

</p>

<!-- 
  Before the docker CLI sends the context to the docker daemon, it looks for a file named .dockerignore in the root directory of the context. If this file exists, the CLI modifies the context to exclude files and directories that match patterns in it. This helps to avoid unnecessarily sending large or sensitive files and directories to the daemon and potentially adding them to images using ADD or COPY.
 -->

<pre><code>
# Common
README.md
CHANGELOG.md
docker-compose.yml
Dockerfile

# Node
## Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

## Dependency directories
node_modules/
</code></pre>


<h3 id="">Example</h3>

<pre><code class="bash">$ cd example
$ npm init -y
$ npm install express morgan
$ touch index.js
$ node index.js
$ curl http://localhost:8080</code></pre>

<pre><code class="javascript"></code></pre>

<pre><code class="dockerfile"></code></pre>

<!-- 
  Start FROM the pre-existing node:current-slim image. This is an official image, built by the node.js vendors and validated by Docker to be a high-quality image containing the Node.js Long Term Support (LTS) interpreter and basic dependencies.

  Use WORKDIR to specify that all subsequent actions should be taken from the directory /usr/src/app in your image filesystem (never the host’s filesystem).

  COPY the file package.json from your host to the present location (.) in your image (so in this case, to /usr/src/app/package.json)
  RUN the command npm install inside your image filesystem (which will read package.json to determine your app’s node dependencies, and install them)

  COPY in the rest of your app’s source code from your host to your image filesystem.

  The CMD directive is the first example of specifying some metadata in your image that describes how to run a container based on this image. In this case, it’s saying that the containerized process that this image is meant to support is npm start.

  The EXPOSE 8080 informs Docker that the container is listening on port 8080 at runtime.
-->

<pre><code class="bash">$ docker build --tag node-docker .
$ docker images
$ docker run -d -p 8000:8000 --name rest-server node-docker

$ docker build --tag hello-world:1.0 .
$ docker run --publish 8000:8080 --detach --name hello-world hello-world:1.0
$ docker rm --force hello-world
$ docker tag bulletinboard:1.0 <Your Docker ID>/bulletinboard:1.0
$ docker push <Your Docker ID>/bulletinboard:1.0</code></pre>

<!-- 
  --publish asks Docker to forward traffic incoming on the host’s port 8000 to the container’s port 8080. Containers have their own private set of ports, so if you want to reach one from the network, you have to forward traffic to it in this way. Otherwise, firewall rules will prevent all network traffic from reaching your container, as a default security posture.

  --detach asks Docker to run this container in the background.

  --name specifies a name with which you can refer to your container in subsequent commands, in this case hello-world.
-->


<h3 id="resources">Resources</h3>

<ul>
  <li>
    <a href="https://docs.docker.com/">Docker Documentation</a>
  </li>
</ul>
